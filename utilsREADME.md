# Utilities

The utils provides tools for exploring knowledge graphs, generating questions, and evaluating question-answering models.

**Core Classes**

### GraphAlgos

`GraphAlgos` provides methods for analyzing and traversing the graph, including Breadth-First Search (BFS), Depth-First Search (DFS), computing the diameter of the graph, and finding a path of a specific length.

```python
graph = load_graph('graph.json')
algos = GraphAlgos(graph)
vertices = algos.get_vertices()
relations = algos.get_relations()
relation = algos.get_relation_for_vertex('Apple_Inc', 'IPhone')
diameter = algos.compute_diameter()
visited = algos.dfs('Apple_Inc')
path = algos.dfs_path('Apple_Inc', 3)
```
### MIstralChecker

Employs a custom Mistral model (loaded from a local path) and the Transformers library for answer correctness evaluation.

```python
checker = MistralChecker(model_path, device)
question = "What is the capital of France?"
ground_truth_answer = "Paris"
model_answer = "Paris"  # The answer provided by your QA model

is_correct, response = checker.raw_checker(question, ground_truth_answer, model_answer, return_response=True)

print(f"Model answer is correct?: {is_correct}")  
print(f"Checker's Response: {response}") 
```

**Detailed Functionality**

* **GraphAlgos:** 
    - ```__init__(self, graph: dict) -> None```: Initializes a new `GraphAlgos` instance.
    - ```bfs(self, start)```: Performs a Breadth-First Search from a specified vertex.
    - ```compute_diameter(self)```: Computes the diameter of the graph.
    - ```dfs(self, start, visited=None)```: Performs a Depth-First Search from a specified vertex.
    - ```dfs_path(self, start, length, path=None)```: Finds a path of a specified length.
    - ```get_vertices(self)```: Returns a list of all vertices in the graph.
    - ```get_relations(self)```: Returns a list of all relations in the graph.
    - ```get_relation_for_vertex(self, start_vertex, target_vertex)```: Returns the relation between two specified vertices.
    - ```generate_random_query(k=5)```: generates random question from knowledge graph where vertices are  at most k distance apart. Also, prints the path for reference.
    - ```create_subgraph_within_radius(self, start_vertex, k) -> dict```: Creates a subgraph containing vertices within a radius 'k' from the given start vertex.
    - ```get_best_vertices(self, num=1000) -> list```: Returns a list of vertices sorted by their out-degree, descending.
   
* **MistralChecker:**
    - ```__init__(self, model_path, device='cuda:1') -> None```: Initializes a new `MistralChecker` instance.
    - ```form_prompt(self, question, correct_ans, model_ans) -> str```: Constructs a prompt suitable for the Mistral model, combining the question, ground truth answer, and model-generated answer.

    - ```checker(self, prompt: str, return_response=False) -> tuple```: 
    The core method for answer correctness assessment. To be only be used after using form_prompt to get the prompt.
    **Returns** A tuple containing:
            A boolean (1 if the model answer is considered correct, 0 otherwise) and 
            (Optionally) The decoded response text generated by the Mistral model.

    - ```raw_checker(self, question, correct_ans, model_ans, return_response=False) -> tuple```: Handles the complete answer correctness checking process. Runs form_prompt and passes the result to checker to get the response from mistral model. **Returns** same as checker output.

* **Alias Handling Functions**

These functions support the generation of more diverse and natural-sounding questions by incorporating aliases for entities and relations within your knowledge graph.

**`get_alias(id, aliases) -> str`**
    * Retrieves a random alias for a given entity or relation ID.
    * **Parameters:**
        * `id`: The ID of the entity or relation.
        * `aliases`: A dictionary mapping IDs to their corresponding lists of aliases.
    * **Returns:** A randomly selected alias from the provided choices.

**`form_alias_question(question, path, entity_aliases, relation_aliases, name2id, graph_algos) -> tuple`**
    * Transforms a question by replacing entity and relation names with their aliases.
    * **Parameters:**
        * `question`: The original question string.
        * `path`: A list representing the path within the knowledge graph relevant to the question.
        * `entity_aliases`: A dictionary mapping entity IDs to their aliases.
        * `relation_aliases`: A dictionary mapping relation IDs to their aliases.
        * `name2id`: A dictionary mapping entity/relation names to their IDs.
        * `graph_algos`: A `GraphAlgos` object for accessing graph information.
    * **Returns:** A tuple containing:
        * The transformed question with aliases.
        * The alias used for the main entity in the question.

**`load_aliases(path) -> dict`**
    * Loads entity and relation aliases from a file.
    * **Parameters:**
        * `path`: The path to the alias file. The file is expected to be tab-separated, with each line containing an entity/relation name followed by its aliases. 
    * **Returns:** A dictionary where keys are entity/relation names and values are lists of their corresponding aliases. The key is the Wikidata ID.

**Example Usage**

```python
entity_aliases = load_aliases('entity_aliases.txt')
relation_aliases = load_aliases('relation_aliases.txt')

# ... (Assuming you have 'question', 'path', 'name2id' and 'graph_algos' set up)
new_question, entity_alias = form_alias_question(question, path, entity_aliases, relation_aliases, name2id, graph_algos)
print(f"Transformed Question: {new_question}")
```

* **GeminiChecker:**
    - ```__init__(self) -> None```: Initializes a new `GeminiChecker` instance. Requires Google API Key in environment variable.
    - ```form_prompt(self, question, correct_ans, model_ans) -> str```: Similar to MistralChecker.

    - ```checker(self, prompt: str, return_response=False) -> tuple```: 
    Similar to MistralChecker.

    - ```raw_checker(self, question, correct_ans, model_ans, return_response=False) -> tuple```: Similar to MistralChecker.

**Dependencies**

* Python 3.x
* requests
* concurrent.futures
* queue
* threading
* random
* copy
* collections
* json
* transformers (from Hugging Face)
* genai (for Google Gemini model)
* PyTorch (for MistralChecker)
* unidecode

**Environment Variables**

* **GOOGLE_API_KEY:** A valid Google API Key is required for using the `GeminiChecker` class.
